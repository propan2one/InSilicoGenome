import os
import numpy as np

def random_dnasequence(size):
    """
    Generate random sequence of DNA

    Parameters
    ----------
    size : Size of DNA in bp
      An integer between 1 and 100 000 000.

    Returns
    -------
    string
      A string corresponding to DNA sequence.

    Examples
    --------
    >>> from insilicogenome import insilicogenome
    >>> insilicogenome.random_dnasequence(10)
    'GTTCTTGAT'
    """
    if ((size>= 0) and (size<= 100000000)):
        pass
    elif (size > 100000000):  # on a title line
        raise ValueError(
            "The size of the sequence to generate is greater than the maximum size of 100000000bp"
            f"The value of '{size}' is too big, it must be reduced"
        )
    else:
        assert size > 0, "Size value negatif ; this should be impossible!"
    np.random.seed(123)
    sequence = ''.join(np.random.choice(('C','G','T','A'), size, p=[0.25, 0.25, 0.25, 0.25] ))
    return sequence

def replace_start_codons(sequence, codon_start_array = ["ATG", "TTG", "CTG"]):
    """
    Replace all the occurence of initiation codon {ATG, TTG, CTG} recusively.
    
    The choice was made to replace the start codons by triplets of identical nucleotides {e.g. AAA or CCC} generated randomly.
    This choice is supposed to reduce the complexity of the recursion

    Parameters
    ----------
    sequence : A sequence of DNA between 1 and 100 000 000bp
      A string generated by random_dnasequence

    Returns
    -------
    string
      A string corresponding to DNA sequence without start codons.

    Examples
    --------
    >>> from insilicogenome import insilicogenome
    >>> insilicogenome.replace_start_codons("GTTCTTGAT")
    'GTTCCCCAT'
    """
    tempRecordSeq = list(sequence)
    iteration=0
    np.random.seed(iteration)
    for index in range(0, len(sequence), 1):
            codon = sequence[index:index+3]
            if codon in codon_start_array:
                tempRecordSeq[index:index+3] = np.random.choice(('C','G','T','A'), 1).repeat(3)
    sequence = "".join(tempRecordSeq)
    iteration = iteration+1
    if (codon_start_array[0] in sequence or codon_start_array[1] in sequence or codon_start_array[2] in sequence and iteration < 100 ):
        print(iteration)
        replace_start_codons(sequence)
    elif (iteration > 1000):
        print(str(err))
        print(f"The complexity is high and iteration={iteration}")
        sys.exit(2)
    else:
        print(f"replace_start_codons() succed with {iteration} iterations")
    return sequence

def write_fasta_genome(output, sequence):
    """
    Writes name/sequence to file in FASTA format

    Parameters
    ----------
    output : The name of the header and fasta file
      A string containing the path
    sequence : A sequence of DNA between 1 and 100 000 000bp
      A string generated by random_dnasequence

    Returns
    -------
    None

    Examples
    --------
    >>> from insilicogenome import insilicogenome
    >>> insilicogenome.write_fasta_genome(/path/genome.fasta, 'GTTCTTGAT')
    """
    # Confirm path make sens, and allow absolut path
    if os.path.isfile(output):
        raise FileExistsError
    # Raise error if not only ACTG in sequence to avoid inversion
    header=os.path.basename(output)
    header=os.path.splitext(header)[0]
    n = 70	# return line every 70 characters
    split_sequence = [sequence[i:i+n] for i in range(0, len(sequence), n)]
    with open(output, 'w') as outfile:
            outfile.write(f">{header}\n")
            for item in split_sequence:
                outfile.write(f"{item}\n")