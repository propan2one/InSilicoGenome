import os
import warnings
import numpy as np

def random_dnasequence(size):
    """
    Generate random sequence of DNA

    Parameters
    ----------
    size : Size of DNA in bp
      An integer between 1 and 100 000 000.

    Returns
    -------
    string
      A string corresponding to DNA sequence.

    Examples
    --------
    >>> from insilicogenome import insilicogenome
    >>> insilicogenome.random_dnasequence(10)
    'TGCTTGATGG'
    """
    if ((size>= 0) and (size<= 100000000)):
        pass
    elif (size > 100000000):  # on a title line
        raise ValueError(
            "The size of the sequence to generate is greater than the maximum size of 100000000bp"
            f"The value of '{size}' is too big, it must be reduced"
        )
    else:
        assert size > 0, "Size value negatif ; this should be impossible!"
    np.random.seed(123)
    sequence = ''.join(np.random.choice(('C','G','T','A'), size, p=[0.25, 0.25, 0.25, 0.25] ))
    return sequence

def replace_start_codons(sequence, codon_start_array = ["ATG", "CAT", "TTG", "CAA", "CTG", "CAG"]):
    """
    Replace all the occurence of initiation codon by random sequence {ATG & CAT, TTG & CAA, CTG & CAG}.
    The CAT, CAA, CAG are the reverse complement sequence of classical start codon

    Parameters
    ----------
    sequence : A sequence of DNA between 1 and 100 000 000bp
      A string generated by random_dnasequence

    Returns
    -------
    string
      A string corresponding to DNA sequence without start codons.

    Examples
    --------
    >>> from insilicogenome import insilicogenome
    >>> insilicogenome.replace_start_codons("GTTCTTGAT")
    'GTTCCCCAT'
    """
    iteration=0
    while (codon_start_array[0] in sequence or codon_start_array[1] in sequence or codon_start_array[2] in sequence):
        if (iteration == 1000):
            break
        else:
            tempRecordSeq = list(sequence)
            np.random.seed(iteration)
            for index in range(0, len(sequence), 1):
                    codon = sequence[index:index+3]
                    if codon in codon_start_array:
                        tempRecordSeq[index:index+3] = np.random.choice(('C','G','T','A'), 3, p=[0.25, 0.25, 0.25, 0.25] )
            sequence = "".join(tempRecordSeq)
            iteration += 1
    return sequence

def insert_random_gene(sequence, strand="+", start, codon_start, stop, codon_stop):
  np.random.seed(123)
  #assert codon_stop not in codon_stop_array,'Error in codon stop definition, provide "TAG", "TAA", "TGA"'
  assert len(sequence)<6 ,'Error in gene size due to a sequence size inferior to 6bp'
  if ((end - start +1) > 75):
    pass
  else:
    warnings.warn('Gene size is abnormally small, check gene size', DeprecationWarning)
  #control codon start
  codon_start_array = ["ATG", "TTG", "CTG"]
  if codon_start is not None:
    codon_start = np.random.choice(codon_start_array, 1, p=[0.34, 0.33, 0.33] )
  else:
    assert codon_start not in codon_start_array,'Error in codon start definition, provide "ATG", "TTG", "CTG"'
  # control codon stop
  codon_stop_array = ["TAG", "TAA", "TGA"]
  if codon_stop is not None:
    codon_stop = np.random.choice(codon_stop_array, 1, p=[0.34, 0.33, 0.33] )
  else:
    assert codon_stop not in codon_stop_array,'Error in codon stop definition, provide "TAG", "TAA", "TGA"'
  #
  if (strand == "+"):
    sequence = sequence[:start] + ''.join(codon_start) + sequence[(start+3)] + \
    sequence[start:(stop-4)] + ''.join(codon_stop)
    return sequence
  else:
    complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'} 
    return ''.join([complement[base] for base in dna[::-1]])
## Incorporate reverse complement to get in second strand 
def reverse_complement(dna): 
  complement = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'} 
  return ''.join([complement[base] for base in dna[::-1]])

np.random.seed(123)
codon_start_array = ["ATG", "TTG", "CTG"]
codon_stop_array = ["TAG", "TAA", "TGA"]
codon_start = "ATG"
codon_stop = "TAG"
sequence = "GTTCTTGATGTTCTTGAT"
len(sequence)
strand = "+"
start = 2
stop = 15

def write_fasta_genome(output, sequence):
    """
    Writes name/sequence to file in FASTA format

    Parameters
    ----------
    output : The name of the header and fasta file
      A string containing the path
    sequence : A sequence of DNA between 1 and 100 000 000bp
      A string generated by random_dnasequence

    Returns
    -------
    None

    Examples
    --------
    >>> from insilicogenome import insilicogenome
    >>> insilicogenome.write_fasta_genome(/path/genome.fasta, 'GTTCTTGAT')
    """
    # Confirm path make sens, and allow absolut path
    if os.path.isfile(output):
        raise FileExistsError
    # Raise error if not only ACTG in sequence to avoid inversion
    header=os.path.basename(output)
    header=os.path.splitext(header)[0]
    n = 70	# return line every 70 characters
    split_sequence = [sequence[i:i+n] for i in range(0, len(sequence), n)]
    with open(output, 'w') as outfile:
            outfile.write(f">{header}\n")
            for item in split_sequence:
                outfile.write(f"{item}\n")